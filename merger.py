__author__ = "Stauros Triantafyllos"
__email__ = "stauros@cocoware.io"


from typing import Optional


class HeterogenousTypeException(Exception):
    def __init__(self, message, path, data):
        self.message = message
        self.path = path
        self.data = data

    def __str__(self):
        return f'Message: {self.message}\nPath: {self.path}\nData: {self.data}'


class NotImplementedException(Exception):
    pass


def homogeneous_type(seq: list) -> Optional[type]:
    """
    Identifies if all elements of a list are of the same type.
    :param seq: The list of elements that are checked.
    :return: The common type of the elements if the type of all elements is the same. If not returns None.
    """

    iseq = iter(seq)
    first_type = type(next(iseq))
    return first_type if all((type(x) is first_type) for x in iseq) else False


def merge_list(a: list, b: list, path: list = [], on_new_field: callable = None) -> list:
    """
    Merges the elements of two lists into a list of one element having all the available fields from all elements.
    :param a: The first list.
    :param b: The second list.
    :param path: The path of the nested field, if the list is a nested list of a dictionary.
    :param on_new_field: The callable function that is called everytime a new field is added.
    :return: A list of one merged item.
    :raises HeterogenousTypeException: When list has heterogenous types.
    :raises NotImplementedException: When a feature is not supported yet, like processing list of lists.
    """

    list_to_merge = a + b

    if not list_to_merge:
        return []

    item_type = homogeneous_type(list_to_merge)
    if not item_type:
        raise HeterogenousTypeException(
            'Heterogenous types at list',
            path=path,
            data=list_to_merge
        )

    if item_type is dict:
        tmp_item = a[0] if a else {}
        for item in list_to_merge:
            merge_dict(tmp_item, item, path, on_new_field)
    elif item_type is list:
        raise NotImplementedException('List of lists are not supported yet!')
    else:
        tmp_item = list_to_merge[0]

    return [tmp_item]


def merge_dict(a: dict, b: dict, path: list = [], on_new_field: callable = None) -> dict:
    """
    Merges two dictionaries into one dictionary that consists of all the fields that exists at the two dicts.
    :param a: The first dictionary.
    :param b: The second dictionary.
    :param path: The path of the nested field, if the dictionary is a nested dict of a dictionary.
    :param on_new_field: The callable function that is called everytime a new field is added.
    :return: A merged dictionary generated by the two dictionaries.
    :raises HeterogenousTypeException: When the type of the dictionary values are heterogenous.
    """

    for key in b:
        if key in a:
            if (a[key] is not None and b[key] is not None) and (type(a[key]) is not type(b[key])):
                raise HeterogenousTypeException(
                    'Heterogenous types at dictionary',
                    path=path + [str(key)],
                    data={'base': a[key], 'input': b[key]}
                )

            if isinstance(b[key], dict):
                if a[key] is None:
                    a[key] = {}
                merge_dict(a[key], b[key], path + [str(key)], on_new_field)

            elif isinstance(b[key], list):
                if a[key] is None:
                    a[key] = []
                a[key] = merge_list(a[key], b[key], path + [str(key)], on_new_field)

            else:
                if a[key] is None and b[key] is not None:
                    a[key] = b[key]
        else:
            if isinstance(b[key], list):
                a[key] = merge_list([], b[key], path + [str(key)], on_new_field)

            elif isinstance(b[key], dict):
                a[key] = {}
                merge_dict(a[key], b[key], path + [str(key)], on_new_field)

            else:
                a[key] = b[key]

            if on_new_field:
                on_new_field(b, path, key, a[key])
    return a
